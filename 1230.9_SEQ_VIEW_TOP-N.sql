------------------------------------------------------------------------------------------
-- SEQUENCE : 순차번호 자동 생성 객체 (PRIMARY KEY에서 순차번호 생성이 필요할때)
------------------------------------------------------------------------------------------

-- 순차번호(PK), 친구이름, 전화, 최종수정일
-- 1 홍길동 010-9999-9999 19/12/30
-- 2 김길동 NULL 19/12/30
DROP SEQUENCE FRIEND_SEQNO;
CREATE SEQUENCE FRIEND_SEQNO
    INCREMENT BY 1
    START WITH 1
    MAXVALUE 9999
    NOCYCLE -- 9999가 끝나면 더이상 만들어지지 않는다.
    --CYCLE : 9999가 끝나면 다시 1부터 만들어진다.
    NOCACHE;    -- 캐시메모리에 미리 만들어놓지 않는다.
    
DROP TABLE FRIEND;
CREATE TABLE FRIEND (
    NUM NUMBER(4) PRIMARY KEY,
    NAME VARCHAR2(50),
    TEL VARCHAR2(30) UNIQUE,
    LAST_MODIFIED DATE DEFAULT SYSDATE);

INSERT INTO FRIEND (NUM, NAME, TEL, LAST_MODIFIED) VALUES( FRIEND_SEQNO.NEXTVAL, '홍길동', '010-9999-9999', SYSDATE);
INSERT INTO FRIEND (NUM, NAME, TEL, LAST_MODIFIED) VALUES( FRIEND_SEQNO.NEXTVAL, '김길동', NULL, SYSDATE);

SELECT * FROM FRIEND;

SELECT FRIEND_SEQNO.CURRVAL FROM DUAL; -- 현재 시퀀스값 확인하기

-- 1~4 다음과 같은 구조의 테이블을 생성하기 위한 테이블 생성하는 SQL문을 작성.
/*  
[ customer 테이블 ] - cno가 주키, phone은 다른사람과 다르게 입력되도록 제한함
		      joindate는 입력하지 않을시 현재날짜로 입력
  cno    cname   joindate    phone         point  levelno
   1   홍길동   17/10/17  010-9999-9999     300     1
   2   이철수   16/09/06  010-9999-9888    NULL     2
   3   홍길순   16/09/07  010-9999-7777      50     3
[ cus_level 테이블 ] - levelno가 주키, levelname은 NOT NULL 조건.
       levelno     levelname
   	1            VVIP
   	2             VIP           
   	3            NORMAL
   	4            BLACK
조건① CUSTOMER 테이블이 있을 시, 테이블을 삭제하고 테이블을 생성하시오 */
DROP TABLE CUSTOMER;
DROP TABLE CUS_LEVEL;
/*
조건② CUSTOMER 테이블은 필드별로 다음의 제약조건을 지킨다.
	CNO : 주키
	CNAME : NULL값을 입력할 수 없다
	JOINDATE : 입력하지 않을 시, 기본적으로 현재날짜로 입력된다
	PHONE : 모든 데이터는 PHONE 값이 모두 다르게 입력된다
	LEVELNO : CUS_LEVEL 테이블의 LEVELNO 필드를 참조하는 외래키 */
CREATE TABLE CUS_LEVEL (
    LEVELNO NUMBER(1) PRIMARY KEY,
    LEVELNAME VARCHAR2(20) NOT NULL
    );
    
INSERT INTO CUS_LEVEL VALUES(1,'VVIP');
INSERT INTO CUS_LEVEL VALUES(2,'VIP');
INSERT INTO CUS_LEVEL VALUES(3,'NORMAL');
INSERT INTO CUS_LEVEL VALUES(4,'BLACK');

DROP SEQUENCE CUS_SQ;
CREATE SEQUENCE CUS_SQ
    INCREMENT BY 1
    START WITH 1
    MAXVALUE 9999
    NOCYCLE
    NOCACHE;

CREATE TABLE CUSTOMER (
    CNO NUMBER(4) PRIMARY KEY,
    CNAME VARCHAR2(10) NOT NULL,
    JOINDATE DATE DEFAULT SYSDATE,
    PHONE VARCHAR2(20) UNIQUE,
    POINT NUMBER(4),
    LEVELNO NUMBER(1) REFERENCES CUS_LEVEL(LEVELNO)
    );

INSERT INTO CUSTOMER VALUES (CUS_SQ.NEXTVAL, '홍길동', TO_DATE('20171017', 'YYYYMMDD'), '010-9999-9999', 300, 1);
INSERT INTO CUSTOMER VALUES (CUS_SQ.NEXTVAL, '이철수', TO_DATE('20160906', 'YYYYMMDD'), '010-9999-9888', NULL, 2);
INSERT INTO CUSTOMER VALUES (CUS_SQ.NEXTVAL, '홍길순', TO_DATE('20160907', 'YYYYMMDD'), '010-9999-7777', 50, 3);
/*
조건③ CUS_LEVEL 테이블은 필드별로 다음의 제약조건을 지킨다
	LEVELNO : 주키
	LEVELNAME : NULL값을 입력할 수 없다
조건④ CUSTOMER 테이블의 CNO번호는 시퀀스(CUS_SQ)를 생성한 뒤 자동생성 번호로 입력되도록 한다
조건⑤ 위 테이블처럼 데이터 입력

5. 위와 같은 두개의 테이블을 이용하여 아래와 같이 출력하는 SQL문도 작성하시오
  cno    cname   joindate    phone         point  levelname
   1   홍길동   2017-10-17  010-9999-9999     300     VVIP
   2   이철수   2016-09-06  010-9999-9888    NULL     VIP
   3   홍길순   2016-09-07  010-9999-7777      50     NORMAL
*/   
   

SELECT CNO, CNAME, TO_CHAR(JOINDATE,'YY-MM-DD'), PHONE, NVL(POINT,0), LEVELNAME 
FROM CUSTOMER C, CUS_LEVEL L
WHERE C.LEVELNO = L.LEVELNO;

------------------------------------------------------------------------------------------
-- VIEW(가상의 테이블)
------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW EMPV0
    AS SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP; -- 단순뷰

SELECT * FROM EMPV0 WHERE DEPTNO = 20;

CREATE OR REPLACE VIEW EMPV0
    AS SELECT EMPNO, ENAME, JOB, DNAME FROM EMP E, DEPT D
        WHERE E.DEPTNO=D.DEPTNO; -- 복합뷰

SELECT * FROM EMPV0;

-- 부서번호가 30인 부서직원들만 EMPV1 뷰생성
CREATE OR REPLACE VIEW EMPV1
    AS SELECT * FROM EMP WHERE DEPTNO=30;

SELECT * FROM EMPV1;

INSERT INTO EMPV1 VALUES(1111,'홍',NULL,NULL,SYSDATE,NULL,NULL,40);

SELECT * FROM EMP;

CREATE OR REPLACE VIEW EMPV1
    AS SELECT * FROM EMP WHERE DEPTNO=30 WITH CHECK OPTION; -- 30번 부서의 직원만 W/R가능

INSERT INTO EMPV1 VALUES(1112,'홍',NULL,NULL,SYSDATE,NULL,NULL,40); -- 실행불가
INSERT INTO EMPV1 VALUES(1112,'홍',NULL,NULL,SYSDATE,NULL,NULL,30); -- 실행가능

CREATE OR REPLACE VIEW EMPV2
    AS SELECT * FROM EMP WHERE DEPTNO=30 WITH READ ONLY; -- SELECT만 가능

INSERT INTO EMPV2 VALUES(1113,'홍',NULL,NULL,SYSDATE,NULL,NULL,30); -- 실행불가

-- INSERT 불가능한 경우
CREATE OR REPLACE VIEW EMPV3
    AS SELECT ENAME, SAL, COMM FROM EMP;

SELECT * FROM EMPV3;
INSERT INTO EMPV3 VALUES('홍',9000,5000);

CREATE OR REPLACE VIEW SALV1
    AS SELECT EMPNO, ENAME, SAL*12 AS YEARSAL FROM EMP WHERE DEPTNO=10;

SELECT * FROM SALV1 WHERE YEARSAL > 20000;

CREATE OR REPLACE VIEW SALV1 (ID, NAME, YEARSAL)
    AS SELECT EMPNO, ENAME, SAL*12 FROM EMP WHERE DEPTNO=10;

INSERT INTO SALV1 VALUES(119,'홍',12000); -- 실행불가
SELECT * FROM SALV1;

CREATE OR REPLACE VIEW DEPTV1 (DEPTNO, MINSAL, MAXSAL, AVGSAL)
    AS SELECT DEPTNO, MIN(SAL), MAX(SAL), AVG(SAL) FROM EMP GROUP BY DEPTNO;

SELECT * FROM DEPTV1;

CREATE OR REPLACE VIEW JOBLIST
    AS SELECT DISTINCT JOB, DEPTNO FROM EMP;

SELECT * FROM JOBLIST;

------------------------------------------------------------------------------------------
-- inline VIEW : FROM 절의 서브쿼리
------------------------------------------------------------------------------------------
-- 급여가 2000을 초과하는 사원의 평균 급여출력
SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL>2000);

-- 이름, 급여, 부서번호, 해당사원의 부서급여평균급여
SELECT ENAME, SAL, DEPTNO, (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO)
FROM EMP E;

DELETE FROM EMP WHERE DEPTNO=40;
COMMIT;

SELECT E.ENAME, E.SAL, E.DEPTNO, S.AVGSAL
FROM EMP E, (SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) S
WHERE E.DEPTNO=S.DEPTNO;

-- 이름, 급여, 부서번호, 부서평균급여 (부서평균보다 많이 받는 사원만 출력)
SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO;

SELECT E.ENAME, E.SAL, S.DEPTNO, AVGSAL
FROM EMP E, (SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) S
WHERE E.DEPTNO=S.DEPTNO 
AND E.SAL > S.AVGSAL;

------------------------------------------------------------------------------------------
-- TOP N 구문
------------------------------------------------------------------------------------------
SELECT ROWNUM, ENAME, SAL FROM EMP; -- ROWNUM: EMP테이블에서 가져온 순서
-- SAL등수, ENAME, SAL
SELECT ROWNUM, ENAME, SAL FROM EMP ORDER BY SAL DESC; -- 등수가 아님

SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL)
WHERE ROWNUM < 6; -- 1등부터 5등까지

SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL)
WHERE ROWNUM BETWEEN 6 AND 10; -- 6등부터 10등까지(X)

SELECT RN, ENAME, SAL FROM (SELECT ROWNUM RN, A.* FROM (SELECT * FROM EMP ORDER BY SAL) A)
WHERE RN BETWEEN 6 AND 10; -- 6등부터 10등까지(O)

SELECT RANK() OVER(ORDER BY SAL) RANK, ENAME, SAL FROM EMP; -- 랭크함수는 등수구분 불가
SELECT DENSE_RANK() OVER(ORDER BY SAL) RANK, ENAME, SAL FROM EMP;
SELECT ROW_NUMBER() OVER(ORDER BY SAL) RANK, ENAME, SAL FROM EMP;


-- 1. 부서명과 사원명을 출력하는 용도의 뷰, DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU
    AS SELECT DNAME, ENAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO;

SELECT * FROM DNAME_ENAME_VU;

-- 2. 사원명과 직속상관명을 출력하는 용도의 뷰,  WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU
    AS SELECT W.ENAME, M.ENAME AS 직속상관 FROM EMP W, EMP M WHERE W.MGR=M.EMPNO;

SELECT * FROM WORKER_MANAGER_VU;

-- 3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수)
SELECT DEPTNO, SUMSAL, ROWNUM 등수 FROM(SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUM(SAL) DESC);

-- 4. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC;

-- 5. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT EMPNO, ENAME, HIREDATE FROM (SELECT ROWNUM RN, A.* FROM EMP A ORDER BY HIREDATE DESC)
WHERE RN < 6;

-- 6. 사원 테이블에서 사번, 사원명, 입사일을 최신부터 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 출력
SELECT RN, EMPNO, ENAME, HIREDATE 
    FROM (SELECT ROWNUM RN, EMPNO, ENAME, HIREDATE FROM 
            (SELECT * FROM EMP ORDER BY HIREDATE DESC))
WHERE RN BETWEEN 6 AND 10;































